rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
Qnew =rbing.matrix.gibbs(cov, diag(rep(1,100)), t(Q))
dim(Qnew)
dim(Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
PPCA()
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
library(rstiefel)
delta = 0.05
d = 200
covMat = sparseCov(d, s=10, k=4)
X = t(mvrnorm(n=200, mu=rep(0,d), Sigma=covMat))
library(MASS)
X = t(mvrnorm(n=200, mu=rep(0,d), Sigma=covMat))
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
X = t(mvrnorm(n=200, mu=rep(0,d), Sigma=covMat))
sampleCov = X %*% t(X)
avr_utility = ExpMech(0.1*0.5*sampleCov, k)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
avr_utility = BMF(0.1*0.5*sampleCov, k)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
quit
exit
k = 4
avr_utility = BMF(0.1*0.5*sampleCov, k=4)
avr_utility = BMF(0.1*0.5*sampleCov, 4)
sampleCov
avr_utility = BMF(0.1*0.5*sampleCov, 4)
avr_utility = BMF(sampleCov, 4)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
avr_utility = ExpMech(sampleCov, 4)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
avr_utility = ExpMech(sampleCov, 4)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
avr_utility = ExpMech(sampleCov, 4)
dim(sampleCov)
type(sampleCov)
class(sampleCov)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
rnorm()
rnorm
a = matrix(rnorm(3*3), nrows=3)
a = matrix(rnorm(3*3), nrow=3)
a
a[,1]
norm(a[,1])
a[,1]*a[,1]
sum(a[,1]*a[,1])
vnorm <- function(v) sqrt( sum(v*v))
lapply(a,vnorm)
a
apply(a,vnorm)
rep(0,10)
list<-foreach(i=1:10) %do% {
i
}
library('foreach')
install.packages("foreach")
library('foreach')
list<-foreach(i=1:10) %do% {
i
}
list
matrix<-foreach(i=1:10,.combine=rbind) %do% {
i
}
matrix
list
list = c(list)
list
list[1]
list[2]
max(list)
max(c(1,2,3))
max(c(list))
max(matrix)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
install.packages("rARPACK")
pi
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
covStruct = sparseCov(d=100, s=30, k=10)
X = t(mvrnorm(n=100, mu=rep(0,100), Sigma=covStruct$cov))
library(MASS)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
X_norm = normalize_data(X)
install.packages("doMC")
X_norm = normalize_data(X)
X = t(mvrnorm(n=100, mu=rep(0,100), Sigma=covStruct$cov))
X_norm = normalize_data(X)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
S = X_norm %*% t(X_norm)/100
MOD_SULQ(S, 100,10, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
MOD_SULQ(S, 100,10, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
MOD_SULQ(S, 100,10, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
Qclac = MOD_SULQ(S, 100,10, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
Qclac = MOD_SULQ(S, 100,10, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
Qclac = MOD_SULQ(S, 100,10, covStruct$Q)
X = t(mvrnorm(n=10000, mu=rep(0,100), Sigma=covStruct$cov))
X_norm = normalize_data(X)
S = X_norm %*% t(X_norm)/100
S = X_norm %*% t(X_norm)/10000
Qclac = MOD_SULQ(S, 10000,10, covStruct$Q)
covStruct = sparseCov(d=100, s=100, k=10)
covStruct = sparseCov(d=50, s=10, k=3)
d= 50
n=10
k=3
X = t(mvrnorm(n=10000, mu=rep(0,d), Sigma=covStruct$cov))
X_norm = normalize_data(X)
S = X_norm %*% t(X_norm)/10000
Qclac = MOD_SULQ(S, 10000,3, covStruct$Q)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
test_SULQ(1000,100000, 10, 30,100)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
test_SULQ(50,10000, 3, 10,100)
source('~/Research/PrivateSparsePCA/simulation/PPCA.R')
test_SULQ(50,10000, 3, 10,100)
citation
citation(package='rARPACK')
citation(package='rstiefel')
'str'+3
'str'+'3'
a = c(1,3,3)
dput(a)
x <- factor(c("a", "b", "b", "a"))
x[0]
x[1]
x[2]
x[3]
levels(x)
rev(levels(x))
levels(x) <- rev(levels(x))
x
typeof(x)
class(x)
x = 1.0
class(x)
x[1]
x[[1]]
x = c(1.0)
class(x)
x =c(1.0, 2.0)
class(x)
attributes(x)
names(x)
is.vector(x)
is.numeric(x)
typeof(x)
atr(x)
attr(x)
x[1]
str ="abc"
class(str)
str[0] ='d'
str
str[1]
str[[1]
]
str$
;
name(str)
names(str)
str$1
str[1]
str[2]
str[[1]]
str[1][2]
a <- factor(c("A","A","B","A","B","B","C","A","C"))
res <- table(a)
type(res)
typeof(res)
class(res)
f <- function() {
x <- 1
y <- 2
c(x, y)
}
f()
rm(f)
f()
f <- function() {
x <- 1
y <- 2
c(x, y)
}
a = "str"
a[2]='c'
a
a
b = "string"
b
install.packages('ggplot2')
autoplot(c(1,2,3))
libarry(ggplot2)
library(ggplot2)
library(ggplot)
install.packages(ggplot)
install.packages("ggplot2")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
install.packages("Stats")
qplot
install.packages("ggplot2")
library(ggplot2)
quit()
library('ggplot2')
require(ggplot2)
install.packages("ggplot2", type="source",dependencies = TRUE)
library(ggplot2)
library('ggplot2')
install.packages("devtools")
library("devtools")
devtools::install_github("plotly/R-api")
install.packages("ggplot2", type="source")
devtools::install_github("plotly/R-api")
library("devtools")
devtools::install_github("plotly/R-api")
remove.packages(ggplot2)
remove.packages("ggplot2")
devtools::install_github("plotly/R-api")
devtools::install_github("plotly/R-api")
library("ggplot2")
ggplot2::version
ggplot2
remove.packages("ggplot2")
remove.packages(ggplot2)
remove.packages("ggplot2")
library("ggplot2")
library("ggplot2")
library("devtools")
devtools::install_github("plotly/R-api")
library("ggplot2")
remove.packages("ggplot2")
install.packages("ggplot2", type="source")
install.packages("ggplot2", type="source")
install.packages("ggplot2", type = "source")
library("ggplot2")
devtools::install_github("hadley/ggplot2")
install.packages("installr", dependencies = FALSE)
library("devtools")
devtools::install_github("hadley/ggplot2")
devtools::install_github("plotly/R-api")
library("plotly")
p <- plotly(username="USERNAME", key="API_Key")
x0 = rnorm(500)
x1 = rnorm(500)+1
data0 = list(x=x0,
type='histogramx',
opacity=0.8)
data1 = list(x=x1,
type='histogramx',
opacity=0.8)
layout = list(barmode='overlay')
response = p$plotly(data0, data1, kwargs=list(layout=layout))
browseURL(response$url)
library(plotly)
p <- plot_ly(midwest, x = percollege, color = state, type = "box")
p
midwest
percollege
devtools::install_github("ropensci/plotly")
percollege
library(plotly)
percollege
set.seed(100)
d <- diamonds[sample(nrow(diamonds), 1000), ]
plot_ly(d, x = carat, y = price, text = paste("Clarity: ", clarity),
mode = "markers", color = carat, size = carat)
carat
price
carat
price
diamonds
plot_ly(d, x = carat, y = price, text = paste("Clarity: ", clarity),
mode = "markers", color = carat, size = carat)
df = data.frame(a=c(1,2), b= c(3,3))
df['a']
df['c']= df['a']^2
df['c']
df2 = copy(df)
df2 = data.frame(df)
df2['d'] = c(3,3)
df2
df
df.colnames
colnames(df)
df["a"]
df["a"] = factor(df["a"])
df["a"] = factor(df[,"a"])
df["a"]
df
df[,"a"]
typeof(df[,"a"])
class(df[,"a"])
class(df[,"b"])
cat("ab","df")
strcat("ab","df")
paste("ab","e")
paste("ab","e", sep="")
paste("ab",3, sep="")
seq(2,5)
seq(2,2)
seq(2,1)
seq(2,1,1)
seq(2,3)
library('qqplot2')
library('ggplot2')
qplot(data=df, x=a, y=b,geom="boxplot")
v=c(1,1,1,2,2,2,3,3,3)
idx=c(1,3,6)
v[idx]
int(0.1*13)
0.3*12
integer(0.1*13)
as.integer(0.1*13)
degrees = factor(seq(1,20))
degrees
for (deg in degrees){}
for (deg in degrees){ print(deg)}
df
df[,'a']
df[1,3]
data.matrix(rep(0,6),nrows=3)
data.matrix(rep(0,6),nrow=3)
data.matrix(rep(0,6),rown=3)
data.matrix(rep(0,6), nrows=3)
data.matrix(rep(0,6), nrow=3)
matrix(rep(0,6), nrows=3)
matrix(rep(0,6), nrow=3)
rep("", 10)
df[,'a']
df[,'b']
df[,'b'] ^2
df[,'b'] ^ 2
df[,'bb'] = df[,'b'] ^ 2
df['bc'] = df[,'b'] ^ 2
df <- data.frame(a=c(1,2,3), b= c(3,3,6))
lm(data=df, b ~ poly(a))
lm(data=df, b ~ poly(a,3))
lm(data=df, b ~ poly(a,2))
library(glmnetUtils)
install.packages("randomForest", dependencies = FALSE)
f <- factor(LETTERS[c(1:3, 3:1)])
f
levels(f) <- c('D', 'D','F')
f
v=c('a')
paste(v,collapose='_')
v[1:1]
df
df3 = df
df3 = copy(df()
)
df3 = copy(df)
install.packages("rJava", dependencies = FALSE)
library(rJava)
install.packages('openNLP', dependencies =True, type='source')
install.packages('openNLP', dependencies =TRUE, type='source')
install.packages('openNLP', dependencies =TRUE, type='source')
install.packages('openNLP', dependencies =TRUE, type='source')
ff <- log(Volume) ~ log(Height) + log(Girth)
m <- model.frame(ff, trees)
model.matrix(ff, m)
mat <- model.matrix(ff, m)
install.packages("plotrix", dependencies = FALSE)
as.list(c(1,2,3))
install.packages("kernlab", dependencies = FALSE)
install.packages("fGarch", dependencies = FALSE)
install.packages("fGarch", dependencies = TRUE)
library(huge)
huge
install.packages("picasso")
rbinom(prob=c(0.2,0.3,0.1))
rbinom(n=3,prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.2,0.3,0.1))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rbinom(n=3, size=1, prob=c(0.9,0.03,0.01))
rnorm(3)
noise <- rnorm(d)
Y.misspecified <- (X%*%beta + noise > 0)
X <- matrix(rnorm(n*d), n, d)
beta <- matrix(rnorm(d), d, 1)
zero_idx <- sample(1:d, 50, replace=FALSE)
beta[zero_idx] <- 0
n <- 200
d <- 100
X <- matrix(rnorm(n*d), n, d)
beta <- matrix(rnorm(d), d, 1)
zero_idx <- sample(1:d, 50, replace=FALSE)
beta[zero_idx] <- 0
noise <- rnorm(d)
Y.misspecified <- (X%*%beta + noise > 0)
Y.misspecified
noise <- rnorm(d)
Y.misspecified <- (X%*%beta + noise > 0)
Y.misspecified <- double(X%*%beta + noise > 0)
double(TRUE)
as.numeric(TRUE)
Y.misspecified <- as.numeric(X%*%beta + noise > 0)
Y.misspecified
set.seed(1024)
n <- 2000
d <- 600
X <- matrix(rnorm(n*d), n, d)
beta <- matrix(rnorm(d), d, 1)
zero_idx <- sample(1:d, 50, replace=FALSE)
beta[zero_idx] <- 0
Y <- X %*% beta + rnorm(n)*0.1
library(picasso)
start.time <- Sys.time()
picasso.fitted.scad <-
picasso(X, Y, family="gaussian", alg="greedy",  nlambda = 100, lambda.min.ratio= 0.1, verbose=TRUE)
end.time <- Sys.time()
print(end.time - start.time)
library(glmnet)
start.time <- Sys.time()
glmnet.fitted <-
glmnet(X, Y, lambda.min.ratio= 0.1, nlambda = 100,  family="gaussian")
end.time <- Sys.time()
print(end.time - start.time)
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("rstudioapi")
rstudioapi::isAvailable("0.99.149")
devtools::install_github("hadley/devtools")
has_devel()
library(devtools)
has_devel()
library(roxygen2)
library(testthat)
devtools::session_info()
remove.packages("picasso", lib="~/libs/Rlibs")
install.packages("picasso")
library(picasso)
library(glmnet)
###Lets make a big problem
set.seed(111)
n=300;p=30000
X=scale(matrix(rnorm(n*p),n,p)+rnorm(n))/sqrt(n-1)*sqrt(n)
cor(X[,1],X[,2])
#y=X[,1:20]%*%runif(20)+rnorm(n)>.5
w = rep(0,p)
Y = rep(0,n)
nz.idx = NULL
for(i in 1:10){
tmp = (i-1)*3000+c(1:5)
w[tmp] = c(3,2,0,0,1.5)
Y=Y+X[,tmp]%*%w[tmp]
nz.idx = c(nz.idx,tmp[c(1,2,5)])
}
Y = Y + rnorm(n)
Y = Y - mean(Y)
system.time(fitp<-picasso(X,Y,type.gaussian = "naive",lambda.min=0.5*sqrt(log(p)/n),standardize=F,nlambda=100,verbose=FALSE,method="l1"))
fitp$df
length(which(fitp$beta[,100]!=0))
fitp$df[100]
fitp$lambda
system.time(fitg<-glmnet(X,Y,lambda=fitp$lambda,standardize=F))
fitg$df
setwd("~/Dropbox/(2017 ORF 350/HW2/datasets_hw2/")
load("train.data.csv")
train.df <- read.csv("train.data.csv")
fit1 <- lm(price ~ bedrooms + bathrooms+ sqft_living + sqft_room, data=train.df)
fit1 <- lm(price ~ bedrooms + bathrooms+ sqft_living + sqft_lot, data=train.df)
fit1
fit2 <- lm(price ~ bedrooms + bathrooms+ sqft_living + sqft_lot + poly(bedrooms, 3) + poly(bathrooms, 3), data=train.df)
